#!/usr/bin/env python2
import functools, itertools

from qform import *


def test_const():
    output("""\
    const_cov:{
        `type`domain~@'[{.qml.const x};0h,-1;`$]};""")
    test("const_cov", qstr("1b"))

def test_wrap():
    """Check type handling in functions generated by wrap.h."""
    output("""\
    wrap_F_cov:{
        (-9h;9h;`type)[0 0 0 2 1 1]~@'[type x@;(1;2.;3h;0x4;5 6;7 8 9.);`$]
        };
    wrap_FF_cov:{
        (-9h;9h;`type;`length)[(0 0 0 2 1 1;
                                0 0 0 2 1 1;
                                0 0 0 2 1 1;
                                2 2 2 2 2 2;
                                1 1 1 2 1 3;
                                1 1 1 2 3 1)]~
            @''[type x .;{x(;)\:/:x}(1;2.;3h;0x4;5 6;7 8 9.);`$]
        };
    wrap_iF_cov:{
        wrap_F_cov[x 0] and
            (-9h;9h;`type)[(0 2 0 2 2 2;
                            1 2 1 2 2 2)]~
                @''[type x .;(1;2.;3h;0x4;5 6;7 8 9.)(;)\:/:(0.;0 0.);`$]
        };
    wrap_fF_cov:{
        wrap_F_cov[x 0.] and
            (-9h;9h;`type)[(0 0 0 2 2 2;
                            1 1 1 2 2 2)]~
                @''[type x .;(1;2.;3h;0x4;5 6;7 8 9.)(;)\:/:(0.;0 0.);`$]
        };
    wrap_iiF_cov:{
        wrap_F_cov[x[0;0]] and
            (-9h;9h;`type)[(0 2 0 2 2 2;
                            2 2 2 2 2 2;
                            0 2 0 2 2 2;
                            2 2 2 2 2 2;
                            2 2 2 2 2 2;
                            2 2 2 2 2 2)|/:0 1]~
                @'''[type x .;{x(;)\:/:x}[(1;2.;3h;0x4;5 6;7 8 9.)],\:\:/:
                              enlist each(0.;0 0.);`$]
        };
    wrap_ffF_cov:{
        wrap_F_cov[x[0.;0.]] and
            (-9h;9h;`type)[(0 0 0 2 2 2;
                            0 0 0 2 2 2;
                            0 0 0 2 2 2;
                            2 2 2 2 2 2;
                            2 2 2 2 2 2;
                            2 2 2 2 2 2)|/:0 1]~
                @'''[type x .;{x(;)\:/:x}[(1;2.;3h;0x4;5 6;7 8 9.)],\:\:/:
                              enlist each(0.;0 0.);`$]
        };""")
    def emit(signature, funcs):
        for func in funcs.split():
            test("wrap_%s_cov[" % signature, qstr(".qml."+func), qstr("1b"))

    emit("F", "cos sin tan acos asin atan")
    emit("FF", "atan2")
    emit("F", "cosh sinh tanh acosh asinh atanh")
    emit("F", "exp log log10 logb expm1 log1p")
    emit("FF", "pow")
    emit("F", "floor ceil fabs")
    emit("FF", "fmod")
    emit("F", "erf erfc lgamma gamma j0 j1 y0 y1 sqrt cbrt")
    emit("FF", "hypot beta")
    emit("fF", "pgammar pgammarc ipgammarc")
    emit("ffF", "pbetar ipbetar")
    emit("F", "ncdf nicdf")
    emit("iF", "stcdf sticdf")
    emit("iiF", "fcdf ficdf")
    emit("fF", "c2cdf c2icdf")
    emit("ffF", "gcdf gicdf")
    emit("iiF", "bncdf bnicdf")
    emit("iF", "pscdf psicdf smcdf smicdf")
    emit("F", "kcdf kicdf")
    test("kicdf", qstr("1e-9"), None)

def test_lapack_type():
    """Check type handling in matrix functions."""

    # Most of the test suite checks numerical results, but here we check
    # specific types, so arguments are specified as q strings.

    # Check approximate output type to detect too few arguments being specified
    # in test and function not being called at all (projection).
    output("""\
    lapack_mn_type:{[f;r;x]r~@[type f@;x;`$]};
    lapack_mn_pq_type:{[f;r;x;y]r~@[type f .;(x;y);`$]};""")

    def emit(result, *args):
        test("lapack_mn_type" if len(args) == 1 else "lapack_mn_pq_type",
             *map(qstr, (".qml."+func, result) + args + ("1b",)))

    # matrix and matrix tuple have same type here
    scalar, vector, matrix, type_error, length_error, domain_error = (
        functools.partial(emit, x)
        for x in "-9h 9h 0h `type `length `domain".split())

    # not suitable for any matrix argument due to 'type
    type_mn = [
        "0.",
        "`",
        "``",
        "(0.;0 0.)",
        "(0.;0 0)",
        "(0 0.;0.)",
        "(0 0;0.)",
        "()",
        "0#0",
        "0#0.",
        "enlist ()",
        "enlist 0#0",
        "enlist 0#0."
    ]

    # not suitable for any matrix argument due to 'length
    length_mn = [
        "(0 0.;0 0 0.)",
        "(0 0;0 0 0.)",
        "(0 0 0.;0 0.)",
        "(0 0 0;0 0.)",
        "(0 0.;0 0.;0 0 0.)",
        "(0 0;0 0.;0 0 0.)"
    ]

    # f(n*n)
    for func in "mdet minv mev mchol".split():
        (scalar if func=="mdet" else matrix)("(0 0;0 0.)")
        (scalar if func=="mdet" else matrix)("(0 0.;0 0)")
        for arg in type_mn:
            type_error(arg)
        type_error("0 0.")
        length_error("enlist 0 0.")
        for arg in length_mn:
            length_error(arg)

    # f(m*n)
    for func in "mqr mqrp mlup msvd".split():
        for arg in type_mn:
            type_error(arg)
        type_error("0 0.")
        matrix("(0 0 0;0 0 0.)")
        matrix("(0 0 0.;0 0 0)")
        for arg in length_mn:
            length_error(arg)

    def type_mn_pq(left, right):
        # left and right should be valid
        type_error("`", "`") # both wrong type
        for arg in type_mn:
            type_error(arg, right) # various left 'type
        type_error("0 0.", right) # left can't be vector
        for arg in type_mn:
            type_error(left, arg) # various right 'type
        type_error("()", "0#0") # both 'type

    def length_mn_pq(left, right):
        # left and right should be valid and match other argument of size 2
        for arg in length_mn:
            length_error(arg, right)
        for arg in length_mn:
            length_error(left, arg)

    # f(m*n, n*p)
    for func in "mm mmx`lflip mmx`rflip mmx`lflip`rflip".split():
        lflip = "`lflip" in func; rflip = "`rflip" in func
        if rflip:
            type_error("(0 0;0 0.)", "0 0")
        else:
            vector("(0 0;0 0.)", "0 0")
        matrix("(0 0;0 0.)", "flip"*rflip+"(0 0 0.;0 0 0)")
        type_mn_pq("(0 0;0 0.)", "enlist "*rflip+"0 0")
        length_mn_pq("(0 0;0 0.)", "enlist "*rflip+"0 0")
        length_error("(0 0;0 0.)", "enlist "*rflip+"0 0 0")
        length_error("(0 0;0 0.)", "flip"*rflip+"(0 0;0 0;0 0)")
        length_error("flip"*lflip+"(0 0 0;0 0 0.)", "(0 0;0 0)")
        if rflip:
            matrix("flip"*lflip+"(0 0 0;0 0 0)", "enlist 0 0 0")
        else:
            vector("flip"*lflip+"(0 0 0;0 0 0)", "0 0 0")

    # f(n*n, n*p)
    for func in "ms mls mlsx`equi mlsx`flip mlsx`flip`equi".split():
        flip = "`flip" in func
        vector("(0 0;0 0.)", "0 0")
        matrix("(0 0;0 0.)", "flip"*flip+"(0 0 0.;0 0 0)")
        type_mn_pq("(0 0;0 0.)", "0 0")
        length_mn_pq("(0 0;0 0.)", "0 0")
        length_error("(0 0;0 0.)", "0 0 0")
        length_error("(0 0;0 0.)", "flip"*flip+"(0 0;0 0;0 0)")
        length_error("flip"*flip+"(0 0 0;0 0 0.)", "(0 0;0 0)")
        length_error("flip"*flip+"(0 0 0;0 0 0)", "0 0 0")

        # ms requires a triangular matrix
        if func == "ms":
            vector("(1 1;0 1)", "0 0")
            vector("(0 1;0 0)", "0 0")
            vector("(1 0;1 1)", "0 0")
            vector("(0 0;1 0)", "0 0")
            domain_error("(1 1;1 1)", "0 0")
            domain_error("(0 1;1 0)", "0 0")
            domain_error("(1 0 1;1 1 0;0 0 1)", "0 0 0")

    # f(m*n, m*p)
    for func in "mlsq mlsqx`svd mlsqx`flip mlsqx`flip`svd".split():
        flip = "`flip" in func
        vector("(0 0;0 0)", "0 0")
        matrix("(0 0;0 0)", "(0 0;0 0)")
        vector("flip"*flip+"(0 0;0 0;0 0)", "0 0 0")
        vector("flip"*flip+"(0 0 0;0 0 0)", "0 0")
        matrix("flip"*flip+"(0 0;0 0;0 0)", "flip"*flip+"(0 0;0 0;0 0)")
        matrix("flip"*flip+"(0 0 0;0 0 0)", "(0 0;0 0)")
        type_mn_pq("(0 0;0 0)", "0 0")
        length_mn_pq("(0 0;0 0)", "0 0")
        length_error("flip"*flip+"(0 0 0;0 0 0)", "0 0 0")
        length_error("flip"*flip+"(0 0 0;0 0 0)", "flip"*flip+"(0 0;0 0;0 0)")

def test_lapack_shape():
    """Check matrix functions for large input data and mismatched shapes."""

    # use decimal digits that have a non-zero binary pattern to make any
    # overwrites more noticeable
    output("""\
    lapack_mn_pq_shape:{[f;r;x;y]r~@[type f .;(x#.1;y#-.9);`$]};
    lapack_0n_pq_shape:{[f;r;t;x;y]r~@[type f .;(.1*(t\:). til each x;y#-.9);`$]};""")

    # use odd sizes to check for block algorithm overread
    # two different small sizes needed to create small buffers and large sizes
    # needed to potentially overwrite them
    sizes = [0, 1, 3, 29, 47, 101, 151, 383, 1009, 2551]

    # extra values to detect if above are insufficient to satisfy conditions
    sizes += [10**6, 10**9, 10**18, 10**21]

    # always choose the smallest matrix that fits the requirements
    combinations = list(sorted(
        itertools.product(sizes, repeat=4),
        key=lambda x: (min(x), x[0]*x[1]+x[2]*x[3], x)))

    # high-level matrix shapes; some referred to by index below
    shapes = (
        lambda m, n: 0 == n and m > 10, # zero-width
        lambda m, n: 0 == m and n > 10, # zero-height
        lambda m, n: min(m, n) and max(m, n) <= 3, # tiny (easily overflown)
        lambda m, n: 1 == n and m > 10, # column (for right argument)
        lambda m, n: 1 < n and m > n * 10, # tall
        lambda m, n: 1 < m and n > m * 10, # wide
        lambda m, n: 10 < m == n # square
    )

    def each(result, cond=None, zero_size=False, triangulars=None):
        def emit(Am, An, Bm, Bn):
            if lflip:
                Am, An = An, Am
            if B != 3 and rmflip:
                Bm, Bn = Bn, Bm
            if B == 3 and rvskip:
                return
            if Am == 0 or Bm == 0:
                return # can't render zero-height with specific width in q
            if triangulars is None:
                test("lapack_mn_pq_shape", qstr(".qml."+func),
                     qstr("9h" if "0h" == result and B == 3 else result),
                     qstr("%s %s" % (Am, An)),
                     qstr("%s %s" % (Bm, Bn)) if B != 3 else Bm,
                     qstr("1b"))
            else:
                for triangular in triangulars.split():
                    test("lapack_0n_pq_shape", qstr(".qml."+func),
                         qstr("9h" if "0h" == result and B == 3 else result),
                         qstr(triangular),
                         qstr("%s %s" % (Am, An)),
                         qstr("%s %s" % (Bm, Bn)) if B != 3 else Bm,
                         qstr("1b"))

        def find(relative=None):
            for Am, An, Bm, Bn in combinations:
                if not shapes[A](Am, An) or not shapes[B](Bm, Bn):
                    continue
                if cond is not None and not cond(Am, An, Bm, Bn):
                    continue
                if relative is not None and not relative(Am, An, Bm, Bn):
                    continue
                assert max(Am, An, Bm, Bn) < 10**6, "add more sizes"
                emit(Am, An, Bm, Bn)
                break

        for A, B in itertools.product(range(len(shapes)), repeat=2):
            if A == 3:
                continue # column vector only for right argument
            if (min(A, B) <= 1) != bool(zero_size):
                continue
            # try both relative buffer sizes: left larger and right larger
            if A > 2:
                find(relative=lambda Am, An, Bm, Bn: Am*An > 3*Bm*Bn)
            if B > 2:
                find(relative=lambda Am, An, Bm, Bn: Am*An*3 < Bm*Bn)
            if max(A, B) <= 2:
                find()

    for func in "mm mmx`lflip mmx`rflip mmx`lflip`rflip".split():
        lflip = "`lflip" in func; rmflip = rvskip = "`rflip" in func
        each("0h", lambda Am, An, Bm, Bn: An == Bm)
        each("`type", zero_size=True)
        each("`length", lambda Am, An, Bm, Bn: An != Bm)

    func = "ms"; lflip = rmflip = rvskip = False
    each("0h", lambda Am, An, Bm, Bn: Am == An == Bm,
         triangulars=">= <=")
    each("`domain", lambda Am, An, Bm, Bn: Am == An == Bm > 1,
         triangulars="<>")
    each("`type", lambda Am, An, Bm, Bn: Am == An, zero_size=True,
         triangulars=">= <=")
    each("`length", lambda Am, An, Bm, Bn: Am == An != Bm,
         triangulars=">= <=")
    each("`length", lambda Am, An, Bm, Bn: Bm == Am != An,
         triangulars=">= <=")

    for func in "mls mlsx`equi mlsx`flip mlsx`flip`equi".split():
        lflip = rmflip = "`flip" in func; rvskip = False
        each("0h", lambda Am, An, Bm, Bn: Am == An == Bm)
        each("`type", lambda Am, An, Bm, Bn: Am == An, zero_size=True)
        each("`length", lambda Am, An, Bm, Bn: Am == An != Bm)
        each("`length", lambda Am, An, Bm, Bn: Bm == Am != An)

    for func in "mlsq mlsqx`svd mlsqx`flip mlsqx`flip`svd".split():
        lflip = rmflip = "`flip" in func; rvskip = False
        # actual operation is slow so skip largest valid result (0h) tests
        each("0h", lambda Am, An, Bm, Bn: Am == Bm and An < 1000)
        each("`type", zero_size=True)
        each("`length", lambda Am, An, Bm, Bn: Am != Bm)

def test_lapack_opt():
    output("""\
    lapack_opt:{`opt~@[get;x;`$]};""")

    def emit(func, *args):
        test("lapack_opt", tuple(map(qstr, (".qml."+func,) + args)), qstr("1b"))

    emit("mmx", "`xflip", "0", "0")
    emit("mlsx", "`eqiu", "0", "0")
    emit("mlsqx", "`sdv", "0", "0")
    emit("mnoopx", "`lwer", "0")
    emit("mnoopx", "`lower`upper", "0")

def test_dot():
    output("""\
    dot_type:{[r;x;y]r~@[type .qml.dot .;(x;y);`$]};""")

    def emit(*args):
        test("dot_type", *map(qstr, args + ("1b",)))

    scalar, type_error, length_error = (
        functools.partial(emit, x) for x in "-9h `type `length".split())

    scalar("0 0", "0 0.")
    scalar("0 0", "(0;0.)")
    type_error("0", "0 0.")
    type_error("``", "0 0.")
    type_error("(0 0;0 0)", "0 0.")
    type_error("0 0", "0.")
    type_error("0 0", "``")
    type_error("0 0", "(0 0.;0 0.)")
    length_error("0 0", "0 0 0")
    length_error("4#0.", "3#0.")
    length_error("0#0", "1#0")
    length_error("2#0", "0#0")

def test_poly():
    output("""\
    poly_type:{x~@[type .qml.poly@;y;`$]};""")

    def emit(*args):
        test("poly_type", *map(qstr, args + ("1b",)))

    real, type_error, length_error, roots_error = (
        functools.partial(emit, x) for x in "9h `type `length `roots".split())

    real("1 0")
    real("(1.;0)")
    real("(1;0.)")
    type_error("`")
    type_error("``")
    type_error("(0.;0 0;`;0.)")
    type_error("0.")
    type_error("0")
    type_error("(0.;(0.;0 0.))")
    type_error("(1.;0 0.)")
    type_error("(1 0;1)")
    type_error("(1 0.;0 0.)")
    type_error("(0.;())")
    type_error("(0.;1#0.)")
    type_error(" (0.;3#0 0 0.)")
    length_error("0#0.")
    length_error("()")
    roots_error("0 1")
    roots_error("0 0")


def tests():
    reps(25)
    prec("1e-3")
    test_const()
    test_wrap()
    test_lapack_type()
    test_lapack_shape()
    test_lapack_opt()
    test_dot()
    test_poly()

if __name__ == "__main__":
    tests()
