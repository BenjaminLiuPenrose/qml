#!/usr/bin/env python2
import functools

from qform import *


def test_const():
    output("""\
    const_cov:{
        `type`domain~@'[{.qml.const x};0h,-1;`$]};""")
    test("const_cov", qstr("1b"))

def test_wrap():
    """Check type handling in functions generated by wrap.h."""
    output("""\
    wrap_F_cov:{
        (-9h;9h;`type)[0 0 0 2 1 1]~@'[type x@;(1;2.;3h;0x4;5 6;7 8 9.);`$]
        };
    wrap_FF_cov:{
        (-9h;9h;`type;`length)[(0 0 0 2 1 1;
                                0 0 0 2 1 1;
                                0 0 0 2 1 1;
                                2 2 2 2 2 2;
                                1 1 1 2 1 3;
                                1 1 1 2 3 1)]~
            @''[type x .;{x(;)\:/:x}(1;2.;3h;0x4;5 6;7 8 9.);`$]
        };
    wrap_iF_cov:{
        wrap_F_cov[x 0] and
            (-9h;9h;`type)[(0 2 0 2 2 2;
                            1 2 1 2 2 2)]~
                @''[type x .;(1;2.;3h;0x4;5 6;7 8 9.)(;)\:/:(0.;0 0.);`$]
        };
    wrap_fF_cov:{
        wrap_F_cov[x 0.] and
            (-9h;9h;`type)[(0 0 0 2 2 2;
                            1 1 1 2 2 2)]~
                @''[type x .;(1;2.;3h;0x4;5 6;7 8 9.)(;)\:/:(0.;0 0.);`$]
        };
    wrap_iiF_cov:{
        wrap_F_cov[x[0;0]] and
            (-9h;9h;`type)[(0 2 0 2 2 2;
                            2 2 2 2 2 2;
                            0 2 0 2 2 2;
                            2 2 2 2 2 2;
                            2 2 2 2 2 2;
                            2 2 2 2 2 2)|/:0 1]~
                @'''[type x .;{x(;)\:/:x}[(1;2.;3h;0x4;5 6;7 8 9.)],\:\:/:
                              enlist each(0.;0 0.);`$]
        };
    wrap_ffF_cov:{
        wrap_F_cov[x[0.;0.]] and
            (-9h;9h;`type)[(0 0 0 2 2 2;
                            0 0 0 2 2 2;
                            0 0 0 2 2 2;
                            2 2 2 2 2 2;
                            2 2 2 2 2 2;
                            2 2 2 2 2 2)|/:0 1]~
                @'''[type x .;{x(;)\:/:x}[(1;2.;3h;0x4;5 6;7 8 9.)],\:\:/:
                              enlist each(0.;0 0.);`$]
        };""")
    def emit(signature, funcs):
        for func in funcs.split():
            test("wrap_%s_cov[" % signature, qstr(".qml."+func), qstr("1b"))

    emit("F", "cos sin tan acos asin atan")
    emit("FF", "atan2")
    emit("F", "cosh sinh tanh acosh asinh atanh")
    emit("F", "exp log log10 logb expm1 log1p")
    emit("FF", "pow")
    emit("F", "floor ceil fabs")
    emit("FF", "fmod")
    emit("F", "erf erfc lgamma gamma j0 j1 y0 y1 sqrt cbrt")
    emit("FF", "hypot beta")
    emit("fF", "pgammar pgammarc ipgammarc")
    emit("ffF", "pbetar ipbetar")
    emit("F", "ncdf nicdf")
    emit("iF", "stcdf sticdf")
    emit("iiF", "fcdf ficdf")
    emit("fF", "c2cdf c2icdf")
    emit("ffF", "gcdf gicdf")
    emit("iiF", "bncdf bnicdf")
    emit("iF", "pscdf psicdf smcdf smicdf")
    emit("F", "kcdf kicdf")
    test("kicdf", qstr("1e-9"), None)

def test_lapack_type():
    """Check type handling in matrix functions."""

    # Most of the test suite checks numerical results, but here we check
    # specific types, so arguments are specified as q strings.

    # Check approximate output type to detect too few arguments being specified
    # in test and function not being called at all (projection).
    output("""\
    lapack_mn_type:{[f;r;x]r~@[type f@;x;`$]};
    lapack_mn_pq_type:{[f;r;x;y]r~@[type f .;(x;y);`$]};""")

    def emit(result, *args):
        test("lapack_mn_type" if len(args) == 1 else "lapack_mn_pq_type",
             *map(qstr, (".qml."+func, result) + args + ("1b",)))

    # matrix and matrix tuple have same type here
    scalar, vector, matrix, type_error, length_error, domain_error = (
        functools.partial(emit, x)
        for x in "-9h 9h 0h `type `length `domain".split())

    # not suitable for any matrix argument due to 'type
    type_mn = [
        "0.",
        "`",
        "``",
        "(0.;0 0.)",
        "(0.;0 0)",
        "(0 0.;0.)",
        "(0 0;0.)"
    ]

    # 'type as general matrix but 'length as column argument
    type_mn_length_m = [
        "()",
        "0#0",
        "0#0."
    ]

    # 'type as general matrix but 'length as square matrix
    type_mn_length_nn = [
        "enlist ()",
        "enlist 0#0",
        "enlist 0#0."
    ]

    # not suitable for any matrix argument due to 'length
    length_mn = [
        "(0 0.;0 0 0.)",
        "(0 0;0 0 0.)",
        "(0 0 0.;0 0.)",
        "(0 0 0;0 0.)",
        "(0 0.;0 0.;0 0 0.)",
        "(0 0;0 0.;0 0 0.)"
    ]

    # f(n*n)
    for func in "mdet minv mev mchol".split():
        (scalar if func=="mdet" else matrix)("(0 0;0 0.)")
        (scalar if func=="mdet" else matrix)("(0 0.;0 0)")
        for arg in type_mn + type_mn_length_m:
            type_error(arg)
        type_error("0 0.")
        length_error("enlist 0 0.")
        for arg in type_mn_length_nn + length_mn:
            length_error(arg)

    # f(m*n)
    for func in "mqr mqrp mlup msvd".split():
        for arg in type_mn + type_mn_length_m + type_mn_length_nn:
            type_error(arg)
        type_error("0 0.")
        matrix("(0 0 0;0 0 0.)")
        matrix("(0 0 0.;0 0 0)")
        for arg in length_mn:
            length_error(arg)

    def type_mn_pq(left, right, left_nn=False):
        # left and right should be valid
        type_error("`", "`") # both wrong type
        for arg in type_mn + type_mn_length_m + type_mn_length_nn*(not left_nn):
            type_error(arg, right) # various left 'type
        type_error("0 0.", right) # left can't be vector
        for arg in type_mn + type_mn_length_nn:
            type_error(left, arg) # various right 'type
        type_error("()", "0#0") # both 'type

    def length_mn_pq(left, right, left_nn=False):
        # left and right should be valid and match other argument of size 2
        for arg in type_mn_length_nn*left_nn + length_mn:
            length_error(arg, right)
        for arg in type_mn_length_m + length_mn:
            length_error(left, arg)

    # f(m*n, n*p)
    for func in "mm".split():
        vector("(0 0;0 0.)", "0 0")
        matrix("(0 0;0 0.)", "(0 0 0.;0 0 0)")
        type_mn_pq("(0 0;0 0.)", "0 0")
        length_mn_pq("(0 0;0 0.)", "0 0")
        length_error("(0 0;0 0.)", "0 0 0")
        length_error("(0 0;0 0.)", "(0 0;0 0;0 0)")
        length_error("(0 0 0;0 0 0.)", "(0 0;0 0)")
        vector("(0 0 0;0 0 0)", "0 0 0")

    # f(n*n, n*p)
    for func in "ms mls mlsx`equi".split():
        vector("(0 0;0 0.)", "0 0")
        matrix("(0 0;0 0.)", "(0 0 0.;0 0 0)")
        type_mn_pq("(0 0;0 0.)", "0 0", left_nn=True)
        length_mn_pq("(0 0;0 0.)", "0 0", left_nn=True)
        length_error("(0 0;0 0.)", "0 0 0")
        length_error("(0 0;0 0.)", "(0 0;0 0;0 0)")
        length_error("(0 0 0;0 0 0.)", "(0 0;0 0)")
        length_error("(0 0 0;0 0 0)", "0 0 0")

        # ms requires a triangular matrix
        if func == "ms":
            vector("(1 1;0 1)", "0 0")
            vector("(0 1;0 0)", "0 0")
            vector("(1 0;1 1)", "0 0")
            vector("(0 0;1 0)", "0 0")
            domain_error("(1 1;1 1)", "0 0")
            domain_error("(0 1;1 0)", "0 0")
            domain_error("(1 0 1;1 1 0;0 0 1)", "0 0 0")

    # f(m*n, m*p)
    for func in "mlsq mlsqx`svd".split():
        vector("(0 0;0 0)", "0 0")
        matrix("(0 0;0 0)", "(0 0;0 0)")
        vector("(0 0;0 0;0 0)", "0 0 0")
        vector("(0 0 0;0 0 0)", "0 0")
        matrix("(0 0;0 0;0 0)", "(0 0;0 0;0 0)")
        matrix("(0 0 0;0 0 0)", "(0 0;0 0)")
        type_mn_pq("(0 0;0 0)", "0 0")
        length_mn_pq("(0 0;0 0)", "0 0")
        length_error("(0 0 0;0 0 0)", "0 0 0")
        length_error("(0 0 0;0 0 0)", "(0 0;0 0;0 0)")

def test_lapack_opt():
    output("""\
    lapack_opt:{`opt~@[get;x;`$]};""")

    def emit(func, *args):
        test("lapack_opt", tuple(map(qstr, (".qml."+func,) + args)), qstr("1b"))

    emit("mlsx", "`eqiu", "0", "0")
    emit("mlsqx", "`sdv", "0", "0")

def test_poly():
    output("""\
    poly_type:{x~@[type .qml.poly@;y;`$]};""")

    def emit(*args):
        test("poly_type", *map(qstr, args + ("1b",)))

    real, type_error, length_error, roots_error = (
        functools.partial(emit, x) for x in "9h `type `length `roots".split())

    real("1 0")
    real("(1.;0)")
    real("(1;0.)")
    type_error("`")
    type_error("``")
    type_error("(0.;0 0;`;0.)")
    type_error("0.")
    type_error("0")
    type_error("(0.;(0.;0 0.))")
    type_error("(1.;0 0.)")
    type_error("(1 0;1)")
    type_error("(1 0.;0 0.)")
    type_error("(0.;())")
    type_error("(0.;1#0.)")
    type_error(" (0.;3#0 0 0.)")
    length_error("0#0.")
    length_error("()")
    roots_error("0 1")
    roots_error("0 0")


def tests():
    reps(25)
    prec("1e-3")
    test_const()
    test_wrap()
    test_lapack_type()
    test_lapack_opt()
    test_poly()

if __name__ == "__main__":
    tests()
